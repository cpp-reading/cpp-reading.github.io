---
layout: post
title : "C++テンプレート完全ガイド読書会vol.1"
category : cpptmp
tags : [C++]
---
{% include JB/setup %}

第1回 開催履歴 1.1～2.3
---

* 日時　：　2014年1月20日(月) 19:30
* 申込　：　[http://atnd.org/events/47159](http://atnd.org/events/47159)
* 会場　：　[フェンリル株式会社](http://www.fenrir-inc.com/)
* 住所　：　大阪市北区大深町3-1 グランフロント大阪 北館 タワーB(オフィス)14F
---
参加人数：10名  
つぶやきまとめ：[http://togetter.com/li/619180](http://togetter.com/li/619180)
---

## 第１章 この本について
---

### 1.1 本書を読む前に知っておくべきこと
---
### 1.2 本書全体の構成  
---
### 1.3 本書の読み方  
---
### 1.4 プログラミングスタイルについて
この書籍でのプログラムのお約束について記載している  
```cpp
const int N;  // (1)
int const N;  // (2)
```

(1)と(2)はどちらも同じ意味  
でも、どちらかというと、(1) の方を良く見るし、よく書くよね  
しかし、この本では(2)でいくらしい

どうしてか？  
```cpp
const int *N;  // (3)
int* const N;  // (4)
```

(3)の場合は、ポインタは変えれないけど、ポインタの中身は変えれる  
(4)の場合は、ポインタは変えれるけど、ポインタの中身は変えれない  
…という違いが (3) と (4) にはある

これを typedef してみた場合を考えてみる  
```cpp
typedef char* CHR;    // (5)
typedef CHR const N;  // (6)
```

typedef はあくまで「char* の意味」として扱うので、これは展開ではない  
なので、  
```cpp
CHR const N;  // (1')
const CHR N;  // (2')
```

この、(1') と (2') は  
　→(1) と (2) の例の様に同じ意味になる！  
　→(3) と (4) の例の「const int * 」と同じにはならない！！  

これは、どちらがイイとか悪いの話では無くて、この「C++テンプレート完全ガイド」では、const を書くときには  
```cpp
int const N;  // (2)
```

(2) のルールで書くことにしようと思う、という筆者のただの宣言  

### 1.5 標準と現実

---
### 1.6 サンプルコードと追加情報

---
### 1.7 ご感想をお寄せください

---
## 第1部
## 第2章 関数テンプレート

---
### 2.1 初めて見る関数テンプレート
---
### 2.1.1 テンプレートを定義する
テンプレートのinline って付けても付けなくても同じだよね？  
→コンパイラの最適化の対象になれるかどうかってだけなので、どっちでもいいでしょう   

#### 2.1.2 テンプレートを使う

---
### 2.2 引数の推論
デフォルトテンプレート引数はC++11では出来るようになっているよ  
C++11 では戻り値も auto で推論してくれる

---
### 2.3 テンプレートパラメータ
ちょっと復習しようよ  
テンプレートって、C++のバージョンでどうやって書かれてるっけ？  

～C++03～
例えば大きい方を返す max テンプレート  
```cpp
template <typename T>
T max( T x, T y ){
  return x < y ? x: y;
}
```
使うとき  
```cpp
max( 1, 2 );     // この式の戻り値の型は int
```

でも、こういうの、したいよね  
```cpp
max( 1, 2.0 );   // やりたいけど、intとdouble で型が違うのでこのままでは出来ない 
```

そこで  
```cpp
template <typename RT, typename T1, typename T2>
RT max( T1 x, T2 y )
```

しかしこれ↑↑↑だと、戻り値全く何かわからなくなったので、自分で指定する  
```cpp
max<double>( 1, 2.0 );
```

C++03の時代はややこしかったねー

～C++11～
こんな感じで記載可能  
```cpp
template<typename T1, typename T2>
auto max( T1 x, T2 y )->decltype( x > y ? x: y ){
  return x < y ? x: y;
}
```

この decltypeの中の式は max( 1, 1.0 ) のとき、double と判る  
なので、戻り値が double と判る  
式を与えたら型を取れる  

なんだかちょっと冗長だけど…  

（余談）  
decletype は型が出てくるところになんでも使える  

```cpp
decltype( std::declval<int>() < std::declval<int>() )
decltype( std::declval<T1>() < std::declval<T2>() )
```

などなど、declval 何やら型が得られるようです  

～C++14～
```cpp
template<typename T1, typename T2>
auto max( T1 x, T2 y ){
    return x < y ? x : y;
}
```
とか  
```cpp
auto max( T1 x, T2 y )->decltype( auto ){
    return x>y?x:y;
}
```

おお！めっちゃ簡素になってる！  
早くC++14が使いたい～

ただし、SFINAEが絡むと話はまた別  
C++14の関数戻り値推論は、SFINAEは行われない

（その他話題）  
decltype()の中には型の付いている式が書ける  
ただし、式の型が付いていないのは  
```cpp
x.*y
```
これ↑↑↑には型が付かない  
右に関数型とか来た時には型が無いのよね  


もちろん、テンプレートよりも非テンプレート版の方が優先されますよ！

---
次回は2.4から！

